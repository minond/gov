#!/bin/bash

[[ "$0" != -* ]] && set -euo pipefail

#=== ENVVARS ==================================================================
#          GOV: Path to G.O.V. root directory.
#          BIN: Path to GOBIN directory that is only used in init command.
#           GO: Path to common and the currently linked version of Go.
#==============================================================================
GOV=${GOV:-~/.gov}
BIN=${BIN:-$GOV/bin}
GO=${GO:-$GOV/go}

#=== GLOBALS ==================================================================
#      VERSIONS: Directory G.O.V. stores downloaded versions.
#     DIR_LINKS: Directory G.O.V. links local versions.
#  DIR_MAPPINGS: File containing maps between directories and go versions.
#       CURRENT: File containing current version string value.
# KNOWN_VERSION: File containing all versions used in list command.
#==============================================================================
VERSIONS="$GOV/versions"
DIR_LINKS="$GOV/dir-links"
DIR_MAPPINGS="$GOV/dir-mappings"
CURRENT="$GOV/current"
KNOWN_VERSION="$GOV/known-versions"

#=== GLOBAL ===================================================================
#         NAME: KNOWN_VERSIONS
#  DESCRIPTION: Temporary solution for adding new known versions to G.O.V. On
#               init, a known-versions file is created and populated with the
#               versions below. Users (or G.O.V.) could update this instead of
#               gov executable when new releases are available.
#         TODO: Don't hardcode versions.
#==============================================================================
KNOWN_VERSIONS=(
  1.11.2 1.11.1 1.11
  1.10.5 1.10.4 1.10.3 1.10.2 1.10.1 1.10
  1.9.7 1.9.6 1.9.5 1.9.4 1.9.3 1.9.2
)

#=== GLOBAL ===================================================================
#         NAME: IS_SUBSHELL
#  DESCRIPTION: Am I running as source or in a subshell? 0 = no, 1 = yes.
#==============================================================================
if [[ "$0" == -* ]]; then
  IS_SUBSHELL=0
else
  IS_SUBSHELL=1
fi

#=== FUNCTION =================================================================
#         NAME: assert
#  DESCRIPTION: Exists with an error when an expected value is not set.
#  PARAMETER 1: Field name/label. Included in error message.
#  PARAMETER 2: Value to check.
#==============================================================================
assert() {
  local label="${1:-}"
  local value="${2:-}"

  if [ -z "$value" ]; then
    err "$label is required"
    exit 1
  fi
}

#=== FUNCTION =================================================================
#         NAME: assert-sourced-execution
#  DESCRIPTION: Exists with an error script is running in a subshell.
#==============================================================================
assert-sourced-execution() {
  if [ "$IS_SUBSHELL" == "1" ]; then
    err "this command expectes to be ran as a source script"
    exit 1
  fi
}

#=== FUNCTION =================================================================
#         NAME: assert-system-requirements
#  DESCRIPTION: Exists with an error when current system is not supported or a
#               dependency is not installed.
#==============================================================================
assert-system-requirements() {
  local os=$(get-os)
  local arch=$(get-arch)

  if [ -z "$os" ] || [ -z "$arch" ]; then
    err "unsupported os/arch: $OSTYPE/$(uname -m)."
    exit 1
  fi

  local has_missing=

  for dep in wget gunzip tar; do
    if ! run-in-unsafe-subshell "which $dep"; then
      err "missing dependency: $dep"
      has_missing=1
    fi
  done

  if [ ! -z "$has_missing" ]; then
    exit 1
  fi
}

#=== FUNCTION =================================================================
#         NAME: run-in-unsafe-subshell
#  DESCRIPTION: Run a command in a subshell with error reporting disabled.
#  PARAMETER *: Command and arguments.
#==============================================================================
run-in-unsafe-subshell() {
  return $(
    set +e
    set +o pipefail

    $@ &> /dev/null

    echo $?
  )
}

#=== FUNCTION =================================================================
#         NAME: arg-or-else-read
#  DESCRIPTION: Returns a given argument and if it is not set reads from stdin.
#  PARAMETER 1: Optional argument value.
#==============================================================================
arg-or-else-read() {
  if [ ! -z "$1" ]; then
    echo "$1"
  else
    read arg
    echo "$arg"
  fi
}

#=== FUNCTION =================================================================
#         NAME: info
#  DESCRIPTION: Print a message.
#  PARAMETER 1: Info message.
#==============================================================================
info() {
  local msg="$1"
  echo "info: $msg"
}

#=== FUNCTION =================================================================
#         NAME: err
#  DESCRIPTION: Print an error message.
#  PARAMETER 1: Error message.
#==============================================================================
err() {
  local msg="$1"
  echo "error: $msg"
}

#=== FUNCTION =================================================================
#         NAME: get-os
#  DESCRIPTION: Prints best guess for the current operating system.
#==============================================================================
get-os() {
  case "$OSTYPE" in
    linux*) echo linux ;;
    darwin*) echo darwin ;;
  esac
}

#=== FUNCTION =================================================================
#         NAME: get-arch
#  DESCRIPTION: Prints best guess for the current architecture.
#==============================================================================
get-arch() {
  case `uname -m` in
    x86_64) echo amd64 ;;
  esac
}

#=== FUNCTION =================================================================
#         NAME: infer-file
#  DESCRIPTION: Prints the file name with version and system info.
#  PARAMETER 1: Golang version.
#==============================================================================
infer-file() {
  local version="$1"
  get-file "$version" "$(get-os)" "$(get-arch)"
}

#=== FUNCTION =================================================================
#         NAME: get-file
#  DESCRIPTION: Prints the file name with version and system info.
#  PARAMETER 1: Golang version.
#  PARAMETER 2: OS from get-os.
#  PARAMETER 3: Architecture from get-arch.
#==============================================================================
get-file() {
  local version="$1"
  local os="$2"
  local arch="$3"
  echo "go${version}.${os}-${arch}"
}

#=== FUNCTION =================================================================
#         NAME: as-tar-file
#  DESCRIPTION: Prints the .tar file name
#  PARAMETER 1: File name
#==============================================================================
as-tar-file() {
  local file=$(arg-or-else-read "$1")
  echo "$file.tar"
}

#=== FUNCTION =================================================================
#         NAME: as-tar-gz-file
#  DESCRIPTION: Prints the .tar.gz file name
#  PARAMETER 1: File name
#==============================================================================
as-tar-gz-file() {
  local file=$(arg-or-else-read "$1")
  echo "$(as-tar-file $file).gz"
}

#=== FUNCTION =================================================================
#         NAME: as-local-version-file
#  DESCRIPTION: Prints the path to a local version file
#  PARAMETER 1: File name
#==============================================================================
as-local-version-file() {
  local file=$(arg-or-else-read "${1:-}")
  echo "$VERSIONS/$file"
}

#=== FUNCTION =================================================================
#         NAME: as-local-version-dir-link
#  DESCRIPTION: Prints the path to a local version link file
#  PARAMETER 1: Full directory path
#==============================================================================
as-local-version-dir-link() {
  local dir=$(arg-or-else-read "$1")
  local clean=$(echo "$dir" | sed -e "s/\//_/g")
  echo "$DIR_LINKS/$clean"
}

#=== FUNCTION =================================================================
#         NAME: as-download-url
#  DESCRIPTION: Prints the .tar.gz download URL
#  PARAMETER 1: File name to download
#==============================================================================
as-download-url() {
  local file=$(arg-or-else-read "$1")
  echo "https://dl.google.com/go/$(as-tar-gz-file $file)"
}

#=== FUNCTION =================================================================
#         NAME: download-it
#  DESCRIPTION: Download a Golang distribution.
#  PARAMETER 1: Golang version.
#==============================================================================
download-it() {
  local version="$1"

  local file=$(infer-file "$version")
  local tar_file=$(as-tar-file "$file")
  local tar_gz_file=$(as-tar-gz-file "$file")
  local local_file=$(as-local-version-file "$file")
  local url=$(as-download-url "$file")

  if [ -d "$local_file" ]; then
    info "located version $version in $VERSIONS"
    return
  fi

  info "downloading $version for $(get-os)/$(get-arch)"
  [ -f "$tar_gz_file" ] && rm "$tar_gz_file"
  info "$url"
  wget --quiet "$url"

  info "gunzip $tar_gz_file"
  [ -f "$tar_file" ] && rm "$tar_file"
  gunzip "$tar_gz_file"

  info "untar $tar_file to $local_file"
  [ -d go ] && rm -r go
  tar -xf "$tar_file"
  mv go "$local_file"

  info "cleaning up"
  rm "$tar_file"
}

#=== FUNCTION =================================================================
#         NAME: link-it-to
#  DESCRIPTION: Link a downloaded version of Golang but only for this directory
#               and session.
#  PARAMETER 1: Golang version.
#  PARAMETER 2: Directory to map version to.
#==============================================================================
link-it-to() {
  local version="$1"
  local dir="$2"

  local local_file=$(infer-file "$version" | as-local-version-file)
  local local_link=$(as-local-version-dir-link "$dir")

  if [ ! -d "$local_file" ]; then
    err "version $version needs to be downloaded before it can linked"
    exit 1
  fi

  if [ -d "$local_link" ]; then
    rm -r "$local_link"
  fi

  info "linking $version from $local_file to $dir"
  ln -s "$local_file" "$local_link"
  info "updating mapping configuration"
  echo "$dir $version" >> "$DIR_MAPPINGS"
}

#=== FUNCTION =================================================================
#         NAME: globally-link-it
#  DESCRIPTION: Link a downloaded version of Golang
#  PARAMETER 1: Golang version.
#==============================================================================
globally-link-it() {
  local version="$1"

  local local_file=$(infer-file "$version" | as-local-version-file)

  if [ ! -d "$local_file" ]; then
    err "version $version needs to be downloaded before it can linked"
    exit 1
  fi

  info "linking $version from $local_file"
  [ -d "$GO" ] && rm -r "$GO"
  ln -s "$local_file" "$GO"
  echo "$version" > "$CURRENT"
}

#=== FUNCTION =================================================================
#         NAME: init
#  DESCRIPTION: Initialize G.O.V.
#==============================================================================
init() {
  if [ ! -d "$VERSIONS" ]; then
    info "creating $VERSIONS"
    mkdir -p "$VERSIONS"
  else
    info "located $VERSIONS"
  fi

  if [ ! -d "$BIN" ]; then
    info "creating $BIN"
    mkdir -p "$BIN"
  else
    info "located $BIN"
  fi

  if [ ! -d "$DIR_LINKS" ]; then
    info "creating $DIR_LINKS"
    mkdir -p "$DIR_LINKS"
  else
    info "located $DIR_LINKS"
  fi

  info "touch $CURRENT"
  touch "$CURRENT"

  info "touch $DIR_MAPPINGS"
  touch "$DIR_MAPPINGS"

  info "touch $KNOWN_VERSION"
  if [ ! -f "$KNOWN_VERSION" ]; then
    info "populating $KNOWN_VERSION"
    touch "$KNOWN_VERSION"
    for v in ${KNOWN_VERSIONS[@]}; do
      echo $v >> "$KNOWN_VERSION"
    done
  fi

  info "make sure to add the following to your bashrc:"
  echo
  echo "    export GOROOT=\"${GO/$HOME/\$HOME}\""
  echo "    export GOBIN=\"${BIN/$HOME/\$HOME}\""
  echo
  echo "    export PATH=\"\$PATH:\$GOROOT/bin\""
  echo "    export PATH=\"\$PATH:\$GOBIN\""
  echo
}

#=== FUNCTION =================================================================
#         NAME: list-them
#  DESCRIPTION: Display a list of Go versions and their installation status.
#==============================================================================
list-them() {
  local current=$(cat "$CURRENT")
  local known_versions=$(cat "$KNOWN_VERSION")

  for version in ${known_versions[@]}; do
    if [ "$current" == "$version" ]; then
      echo "  * $version (current)"
    elif [ -d $(infer-file "$version" | as-local-version-file) ]; then
      echo "  * $version"
    else
      echo "    $version"
    fi
  done
}

#=== FUNCTION =================================================================
#         NAME: help
#  DESCRIPTION: Show help information.
#  PARAMETER 1: Include header
#==============================================================================
help() {
  local header="$1"

  if [ ! -z "$header" ]; then
  cat <<EOF
G.O.V. is a tool for managing Go versions.

EOF
  fi

  cat <<EOF
Usage:

        gov <command> [arguments]

The commands are:

        help                show this help output
        init                initialize G.O.V.
        list                display a list of Go versions and their installation status
        download <version>  download a specific version
        use <version>       download and globally link a specific version
        local <version>     download and locally link a specific version

Environment variables:

        \$GOV               path to G.O.V. root directory: ${GOV/$HOME/~}
        \$BIN               path to GOBIN directory that is only used in init command: ${BIN/$HOME/~}
        \$GO                path to common and the currently linked version of Go: ${GO/$HOME/~}
EOF
}

main() {
  if [ -z "${1:-}" ]; then
    help 1
    exit 1
  fi

  case "$1" in
  -h|-help|--help|help) help 1; exit ;;

  init) init ;;
  list) list-them ;;

  download) shift; assert version "$1"; download-it "$1" ;;
  use)      shift; assert version "$1"; download-it "$1"; globally-link-it "$1" ;;
  local)    shift; assert-sourced-execution; assert version "$1"; download-it "$1"; link-it-to "$1" $(pwd) ;;

  *) err "invalid command: $1"; help; exit ;;
  esac
}

assert-system-requirements
main $*
